require 'gsrubylib/basic'    # Should be unnecessary, but then, this
                             # file shouldn't be loaded directly anyway.

# Most of this code is taken from the Ruby/Extensions probject sort-of hosted at
# https://github.com/rubyblackbelt/ruby_extensions

#
#
# SECTION:   Object
# Methods:   in?   not_nil?   non_nil?   pp_s   singleton_class   define_method
#
#

#
# Object#in?
#
GS::Basic.implement(Object, :in?) do
  class Object
    #
    # Test this object for inclusion in a given collection.
    #
    #   45.in? (1...100)             => true
    #
    # This method is contained in <tt>object.rb</tt> and
    # <tt>enumerable.rb</tt>, because it logically belongs in both.
    #
    def in?(enumerable)
      enumerable.include?(self)
    end
  end
end


#
# Object#not_nil?
#
GS::Basic.implement(Object, :not_nil?) do
  class Object
    #
    # The opposite of <tt>#nil?</tt>.
    #
    #   "hello".not_nil?      # -> true
    #   nil.not_nil?          # -> false 
    #
    def not_nil?
      not self.nil?
    end
  end
end


#
# Object#non_nil?
#
GS::Basic.implement(Object, :non_nil?) do
  class Object
    #
    # The opposite of <tt>#nil?</tt>.
    #
    #   "hello".non_nil?      # -> true
    #   nil.non_nil?          # -> false 
    #
    def non_nil?
      not self.nil?
    end
  end
end


#
# Object#pp_s
#
GS::Basic.implement(Object, :pp_s) do
  require 'pp'
  require 'stringio'
  class Object
    #
    # Returns a pretty-printed string of the object.  Requires libraries +pp+ and
    # +stringio+ from the Ruby standard library.
    #
    # The following code pretty-prints an object (much like +p+ plain-prints an
    # object):
    #
    #   pp object
    #
    # The following code captures the pretty-printing in +str+ instead of
    # sending it to +STDOUT+.
    #
    #   str = object.pp_s 
    #
    def pp_s
      pps = StringIO.new
      PP.pp(self, pps)
      pps.string.chomp
    end
  end
end


#
# Object#define_method
#
GS::Basic.implement(Object, :define_method) do
  class Object
    #
    # Defines a singleton method on the object.  For example, the following are
    # equivalent (assume <tt>o = Object.new</tt>):
    #
    #   def o.add(x, y)
    #     x + y
    #   end
    #
    #   o.define_method(:add) do |x, y|
    #     x + y
    #   end
    #
    # The difference is that with <tt>define_method</tt>, you can use variables
    # local to the _current_ scope.
    #
    #   x = 5 
    #   o.define_method(:add_x) do |n|
    #     x + n
    #   end
    #   o.add_x(11)          # -> 16
    #
    # You can't define such a method as <tt>add_x</tt> above with <tt>def
    # o.add_x; x + n; end</tt>, as +def+ introduces a new scope.
    #
    # There are three ways to provide the body of the method: with a block (as
    # in both examples above), or with a +Proc+ or +Method+ object.  See the
    # built-in method <tt>Module#define_method</tt> for details.
    #
    # (This method is exactly equivalent to calling <tt>Module#define_method</tt>
    # in the scope of the singleton class of the object.) 
    #
    def define_method(*args, &block)
      singleton_class = class << self; self; end
      singleton_class.module_eval do
        define_method(*args, &block)
      end
    end
  end
end


#
#
# SECTION:   Enumerable
# Methods:   build_hash  (graph)   mapf  (collectf)
#
#

#
# Enumerable#build_hash
#
GS::Basic.implement(Enumerable, :build_hash) do
  module Enumerable
    #
    # Like <tt>#map</tt>/<tt>#collect</tt>, but it generates a Hash.  The block
    # is expected to return two values: the key and the value for the new hash.
    #   numbers  = (1..3)
    #   squares  = numbers.build_hash { |n| [n, n*n] }   # 1=>1, 2=>4, 3=>9
    #   sq_roots = numbers.build_hash { |n| [n*n, n] }   # 1=>1, 4=>2, 9=>3
    #
    def build_hash
      result = {}
      self.each do |elt|
        key, value = yield elt
        result[key] = value
      end
      result
    end
  end
end


#
# Enumerable#graph
#
GS::Basic.implement(Enumerable, :graph) do
  module Enumerable
    alias graph build_hash
  end
end


#
# Enumerable#mapf
#
GS::Basic.implement(Enumerable, :mapf) do
  module Enumerable
    #
    # "map function"
    #   enum.mapf(:x)
    # is short for
    #   enum.map { |elt| elt.x }
    #
    def mapf(message)
      self.map { |elt| elt.send(message) }
    end
  end
end


#
# Enumerable#collectf
#
GS::Basic.implement(Enumerable, :collectf) do
  module Enumerable
    alias collectf mapf
  end
end


#
#
# SECTION:   Hash
# Methods:   apply_keys   apply_values
#
#

#
# * Hash#apply_keys
#
GS::Basic.implement(Hash, :apply_keys) do
  class Hash
    # Returns a new hash with the same values as this one but keys that have
    # been generated by the passed-in block.
    #
    # h = { "several" => :nice, "people" => 8 }
    # h.apply_keys { |key| key.length }
    #                                      # -> { 7 => :nice, 6 => 8 }
    #
    # See also: Enumerable#build_hash
    def apply_keys(&block)
      h = Hash.new(&default_proc)
      self.each do |key, value|
        new_key = block.call(key)
        h[new_key] = value
      end
      h
    end
  end
end


#
# * Hash#apply_values
#
GS::Basic.implement(Hash, :apply_values) do
  class Hash
    # Returns a new hash with the same keys as this one but new values
    # calculated by the passed-in block.
    #
    # h = { tom: 37, jane: 51 }
    # h.apply_values { |age| age + 1 }
    #                                      # -> { tom: 38, jane: 52 }
    #
    # See also: Enumerable#build_hash
    def apply_values(&block)
      h = Hash.new(&default_proc)
      self.each do |key, value|
        new_value = block.call(value)
        h[key] = new_value
      end
      h
    end
  end
end


#
#
# SECTION:   String
# Methods:   indent   tabto   trim
#
#

#
# String#leftmost_indent   (protected)
#
GS::Basic.implement(String, :leftmost_indent) do
  class String
    #
    # Returns the size of the smallest indent of any line in the string.  This
    # method is primarily intended for use by #tabto and #trim and is not likely
    # to be all that useful in its own right.
    #
    # Fails if the string contains tabs.
    #
    def leftmost_indent
      tabs_found = false
      scan(/^([ \t]*)\S/).flatten.map { |ws|
        tabs_found = true if ws =~ /\t/
        ws.size
      }.compact.min
    ensure
      if tabs_found
        fail ArgumentError, "String#leftmost_indent requires no tabs"
      end
    end
    protected :leftmost_indent
  end
end


#
# * String#indent
#
GS::Basic.implement(String, :indent) do
  class String
    #
    # Indents each line of the string +n+ spaces.
    #
    def indent(n)
      n = Integer(n)
      if n < 0
        fail ArgumentError, "String#indent requires n >= 0"
      end
      gsub(/^/, ' ' * n)
    end
  end
end



#
# String#tabto
#
GS::Basic.implement(String, :tabto) do
  class String
    #
    # Move the string to the <tt>n</tt>th column.  Relative indentation is preserved.
    # Column indices begin at 0, so the result is that the leftmost character of
    # the string has +n+ spaces before it.
    #
    # Examples:
    #   "xyz".tabto(0)           # -> "xyz"
    #   "xyz".tabto(1)           # -> " xyz"
    #   "xyz".tabto(2)           # -> "  xyz"
    #   "   xyz".tabto(1)        # -> " xyz"
    #
    #   str = <<EOF
    #       Hello, my name
    #     is Gerald.
    #   EOF
    #   str.tabto(5) == <<EOF    # -> true
    #          Hello, my name
    #        is Gerald.
    #   EOF
    #
    def tabto(n)
      n = n.to_int
      n = 0 if n < 0
      find = " " * leftmost_indent()
      replace = " " * (n)
      gsub(/^#{find}/, replace)
    end
  end
end


#
# * String#trim
#
GS::Basic.implement(String, :trim) do
  class String
    #
    # Trims a string:
    # - removes one initial blank line
    # - removes trailing spaces on each line
    # - if +margin+ is given, removes initial spaces up to and including
    #   the margin on each line, plus one space
    #
    # This is designed specifically for working with inline documents.
    # Here-documents are great, except they tend to go against the indentation
    # of your code.  This method allows a convenient way of using %{}-style
    # documents.  For instance:
    #
    #   USAGE = %{
    #     | usage: prog [-o dir] -h file...
    #     |   where
    #     |     -o dir         outputs to DIR
    #     |     -h             prints this message
    #   }.trim("|")
    #
    #   # USAGE == "usage: prog [-o dir] -h file...\n  where"...
    #   # (note single space to right of margin is deleted)
    #
    def trim(margin=nil)
      s = self.dup
      # Remove initial blank line.
      s.sub!(/\A[ \t]*\n/, "")
      # Cut whitespace on the left, using the margin if specified.
      if margin.nil?
        s = s.tabto(0)
      else
        margin_re = Regexp.escape(margin || "")
        margin_re = /^[ \t]*#{margin_re} ?/
        s.gsub!(margin_re, "")
      end
      # Remove trailing whitespace on each line.
      s.gsub!(/[ \t]+$/, "")
      s
    end
  end
end



#
#
# SECTION:   StringIO
# Methods:   StringIO.string
#
#

require 'stringio'

#
# * StringIO.string
#
GS::Basic.implement(StringIO, :string, :class) do
  class String
    #
    # Use StringIO to construct a string, which is returned immediately.
    #
    #   StringIO.string { |o|
    #     o.puts "This"
    #     o.puts "That"
    #     o.puts "The other"
    #   }
    #
    def StringIO.string
      o = StringIO.new
      yield o
      o.string
    end
  end
end



#
#
# SECTION:   Class
# Methods:   attr_predicate  attr_predicate_rw
#
#

#
# * Class#attr_predicate
#
GS::Basic.implement(Class, :attr_predicate, :instance) do
  class Class
    #
    # Defines a read-only predicate in a class, like:
    #
    #   class Polygon
    #     attr_predicate :regular
    #     ...
    #   end
    #   p = Polygon.new(...)
    #   p.regular?
    #   p.regular = true           # NoMethodError; this is read-only
    #
    # See also Class#attr_predicate_rw.
    #
    def attr_predicate(*names)
      unless names.all? { |n| Symbol === n or String === n }
        fail ArgumentError, "Class#attr_predicate requires symbol(s) or string(s)"
      end
      names.each do |name|
        inst_variable_name = "@#{name}".to_sym
        define_method "#{name}?" do
          !! instance_variable_get(inst_variable_name)
        end
      end
    end
  end
end
class Class
  private :attr_predicate
end


#
# * Class#attr_predicate_rw
#
GS::Basic.implement(Class, :attr_predicate_rw, :instance) do
  class Class
    #
    # Defines a read/write predicate in a class, like:
    #
    #   class Polygon
    #     attr_predicate_rw :regular
    #     ...
    #   end
    #   p = Polygon.new(...)
    #   p.regular?
    #   p.regular = true
    #
    # See also Class#attr_predicate (read-only).
    #
    def attr_predicate_rw(*names)
      unless names.all? { |n| Symbol === n or String === n }
        fail ArgumentError, "Class#attr_predicate_rw requires symbol(s) or string(s)"
      end
      names.each do |name|
        inst_variable_name = "@#{name}".to_sym
        define_method "#{name}=" do |value|
          instance_variable_set inst_variable_name, value
        end
        define_method "#{name}?" do
          !! instance_variable_get(inst_variable_name)
        end
      end
    end
  end
end
class Class
  private :attr_predicate_rw
end

